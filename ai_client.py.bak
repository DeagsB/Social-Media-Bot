import os
from typing import Optional
import requests
from openai import OpenAI


class AIClient:
    """Wrapper for the OpenAI modern client (OpenAI()).

    Reads API key from env OPENAI_API_KEY or from storage setting OPENAI_API_KEY.
    """

    def __init__(self, api_key: Optional[str] = None):
        key = api_key or os.getenv("OPENAI_API_KEY")
        if not key:
            try:
                from storage import get_setting

                key = get_setting("OPENAI_API_KEY")
            except Exception:
                key = None

        if not key:
            raise RuntimeError("OpenAI API key not found. Set OPENAI_API_KEY or store in settings.")

        self.client = OpenAI(api_key=key)

    def generate_text(self, prompt: str, max_tokens: int = 150, temperature: float = 0.8) -> str:
        """Generate text using chat completions or responses as a fallback.

        Returns the generated string or raises an exception on unrecoverable errors.
        """
        # Try Chat Completions (modern client)
        try:
            resp = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                temperature=temperature,
            )
            choices = getattr(resp, "choices", None)
            if choices and len(choices) > 0:
                msg = choices[0]
                # Depending on client version, message may be nested
                content = None
                if hasattr(msg, "message") and hasattr(msg.message, "content"):
                    content = msg.message.content
                elif hasattr(msg, "delta") and hasattr(msg.delta, "content"):
                    content = msg.delta.content
                elif isinstance(msg, dict):
                    # dict-style fallback
                    m = msg.get("message") or msg.get("delta") or {}
                    if isinstance(m, dict):
                        content = m.get("content")
                if isinstance(content, str):
                    return content.strip()
                # if content is something else (list/dict), stringify safely
                if content is not None:
                    return str(content).strip()
        except Exception:
            # Fall through to Responses API
            pass

        # Try Responses API
        try:
            resp = self.client.responses.create(model="gpt-4o-mini", input=prompt, max_tokens=max_tokens)
            # Prefer output_text attribute if present
            if hasattr(resp, "output_text") and resp.output_text:
                return resp.output_text.strip()
            # Otherwise parse output items
            outputs = getattr(resp, "output", None) or []
            texts = []
            for item in outputs:
                if isinstance(item, dict) and "content" in item:
                    for c in item["content"]:
                        if c.get("type") == "output_text":
                            texts.append(c.get("text", ""))
            return "\n".join(texts).strip()
        except Exception as e:
            # Surface error to caller for logging/handling upstream
            raise RuntimeError(f"AI text generation failed: {e}")

    def generate_image(self, prompt: str, out_path: str, size: str = "1024x1024") -> str:
        """Generate an image and save to out_path. Returns out_path on success."""
        try:
            resp = self.client.images.generate(model="gpt-image-1", prompt=prompt, size=size)
        except Exception as e:
            raise RuntimeError(f"AI image generation failed: {e}")

        data = getattr(resp, "data", None)
        if not data or len(data) == 0:
            raise RuntimeError("No image returned from API")

        item = data[0]
        # item may be dict-like
        url = item.get("url") if isinstance(item, dict) else None
        b64 = item.get("b64_json") if isinstance(item, dict) else None

        if url:
            r = requests.get(url, stream=True, timeout=15)
            r.raise_for_status()
            with open(out_path, "wb") as f:
                for chunk in r.iter_content(1024):
                    f.write(chunk)
            return out_path

        if b64:
            import base64

            with open(out_path, "wb") as f:
                f.write(base64.b64decode(b64))
            return out_path

        raise RuntimeError("Image response did not contain url or b64 data")
